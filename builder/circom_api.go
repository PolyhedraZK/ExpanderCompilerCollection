package builder

import (
	"fmt"
	"math/big"

	"github.com/PolyhedraZK/ExpanderCompilerCollection/expr"
	"github.com/consensys/gnark/constraint/solver"
	"github.com/consensys/gnark/frontend"
)

// CircomAPI defines a set of functions for implementing operators in Circom, with semantics identical to those in Circom.
// In certain scenarios, these functions do not generate constraints.
// They should only be called by Go code generated by the circom_preprocessor and should not be called manually.
type CircomAPI interface {
	// Infix Operators
	CircomDiv(frontend.Variable, frontend.Variable) frontend.Variable
	CircomPow(frontend.Variable, frontend.Variable) frontend.Variable
	CircomIntDiv(frontend.Variable, frontend.Variable) frontend.Variable
	CircomMod(frontend.Variable, frontend.Variable) frontend.Variable
	CircomShiftL(frontend.Variable, frontend.Variable) frontend.Variable
	CircomShiftR(frontend.Variable, frontend.Variable) frontend.Variable
	CircomLesserEq(frontend.Variable, frontend.Variable) frontend.Variable
	CircomGreaterEq(frontend.Variable, frontend.Variable) frontend.Variable
	CircomLesser(frontend.Variable, frontend.Variable) frontend.Variable
	CircomGreater(frontend.Variable, frontend.Variable) frontend.Variable
	CircomEq(frontend.Variable, frontend.Variable) frontend.Variable
	CircomNotEq(frontend.Variable, frontend.Variable) frontend.Variable
	CircomBoolOr(frontend.Variable, frontend.Variable) frontend.Variable
	CircomBoolAnd(frontend.Variable, frontend.Variable) frontend.Variable
	CircomBitOr(frontend.Variable, frontend.Variable) frontend.Variable
	CircomBitAnd(frontend.Variable, frontend.Variable) frontend.Variable
	CircomBitXor(frontend.Variable, frontend.Variable) frontend.Variable

	// Prefix Operators
	CircomBoolNot(frontend.Variable) frontend.Variable
	CircomComplement(frontend.Variable) frontend.Variable
}

func init() {
	solver.RegisterHint(CircomPowHint)
	solver.RegisterHint(CircomIntDivHint)
	solver.RegisterHint(CircomModHint)
	solver.RegisterHint(CircomShiftLHint)
	solver.RegisterHint(CircomShiftRHint)
	solver.RegisterHint(CircomLesserEqHint)
	solver.RegisterHint(CircomGreaterEqHint)
	solver.RegisterHint(CircomLesserHint)
	solver.RegisterHint(CircomGreaterHint)
	solver.RegisterHint(CircomEqHint)
	solver.RegisterHint(CircomNotEqHint)
	solver.RegisterHint(CircomBoolOrHint)
	solver.RegisterHint(CircomBoolAndHint)
	solver.RegisterHint(CircomBitOrHint)
	solver.RegisterHint(CircomBitAndHint)
	solver.RegisterHint(CircomBitXorHint)
	solver.RegisterHint(CircomBoolNotHint)
	solver.RegisterHint(CircomComplementHint)
}

func (builder *builder) CircomDiv(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	_, v2Constant := builder.constantValue(v2)
	if !v2Constant {
		s, _ := builder.NewHint(DivHint, 1, builder.eOne, v2)
		// circom does not add constraint in this case
		return builder.Mul(s[0], v1)
	}
	return builder.Div(a, b)
}

func CircomPowHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	outputs[0] = big.NewInt(0).Exp(inputs[0], inputs[1], field)
	return nil
}

func (builder *builder) CircomPow(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v2Constant {
		b2 := builder.field.ToBigInt(n2)
		if v1Constant {
			b1 := builder.field.ToBigInt(n1)
			out := big.NewInt(0).Exp(b1, b2, builder.Field())
			return expr.NewConstantExpression(builder.field.FromInterface(out))
		}
		if b2.IsUint64() && b2.Uint64() == 2 {
			return builder.Mul(a, a)
		}
	}
	s, _ := builder.NewHint(CircomPowHint, 1, v1, v2)
	return s[0]
}

func CircomIntDivHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if inputs[1].IsUint64() && inputs[1].Uint64() == 0 {
		return fmt.Errorf("div by constant(0)")
	}
	outputs[0] = big.NewInt(0).Div(inputs[0], inputs[1])
	return nil
}

func (builder *builder) CircomIntDiv(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		if n2.IsZero() {
			panic("div by constant(0)")
		}
		b1 := builder.field.ToBigInt(n1)
		b2 := builder.field.ToBigInt(n2)
		b1.Div(b1, b2)
		return expr.NewConstantExpression(builder.field.FromInterface(b1))
	}
	s, _ := builder.NewHint(CircomIntDivHint, 1, v1, v2)
	return s[0]
}

func CircomModHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) (res error) {
	if inputs[1].IsUint64() && inputs[1].Uint64() == 0 {
		return fmt.Errorf("mod by constant(0)")
	}
	outputs[0] = big.NewInt(0).Mod(inputs[0], inputs[1])
	return nil
}

func (builder *builder) CircomMod(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		if n2.IsZero() {
			panic("mod by constant(0)")
		}
		b1 := builder.field.ToBigInt(n1)
		b2 := builder.field.ToBigInt(n2)
		b1.Mod(b1, b2)
		return expr.NewConstantExpression(builder.field.FromInterface(b1))
	}
	s, _ := builder.NewHint(CircomModHint, 1, v1, v2)
	return s[0]
}

func circomShiftLImpl(x *big.Int, k *big.Int, field *big.Int) *big.Int {
	two := big.NewInt(2)
	top := new(big.Int).Div(field, two)
	if k.Cmp(top) <= 0 {
		shift := field.BitLen()
		if k.IsUint64() && k.Uint64() < uint64(shift) {
			shift = int(k.Uint64())
		}
		value := new(big.Int).Lsh(x, uint(shift))
		mask := new(big.Int).Lsh(big.NewInt(1), uint(field.BitLen()))
		mask.Sub(mask, big.NewInt(1))
		value.And(value, mask)
		value.Mod(value, field)
		return value
	}
	return circomShiftRImpl(x, new(big.Int).Sub(field, k), field)
}

func circomShiftRImpl(x *big.Int, k *big.Int, field *big.Int) *big.Int {
	two := big.NewInt(2)
	top := new(big.Int).Div(field, two)
	if k.Cmp(top) <= 0 {
		shift := field.BitLen()
		if k.IsUint64() && k.Uint64() < uint64(shift) {
			shift = int(k.Uint64())
		}
		value := new(big.Int).Rsh(x, uint(shift))
		return value
	}
	return circomShiftLImpl(x, new(big.Int).Sub(field, k), field)
}

func CircomShiftLHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	outputs[0] = circomShiftLImpl(inputs[0], inputs[1], field)
	return nil
}

func CircomShiftRHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	outputs[0] = circomShiftRImpl(inputs[0], inputs[1], field)
	return nil
}

func (builder *builder) CircomShiftL(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		out := circomShiftLImpl(builder.field.ToBigInt(n1), builder.field.ToBigInt(n2), builder.Field())
		return expr.NewConstantExpression(builder.field.FromInterface(out))
	}
	s, _ := builder.NewHint(CircomShiftLHint, 1, v1, v2)
	return s[0]
}

func (builder *builder) CircomShiftR(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		out := circomShiftRImpl(builder.field.ToBigInt(n1), builder.field.ToBigInt(n2), builder.Field())
		return expr.NewConstantExpression(builder.field.FromInterface(out))
	}
	s, _ := builder.NewHint(CircomShiftRHint, 1, v1, v2)
	return s[0]
}

func circomComparableElement(elem *big.Int, field *big.Int) *big.Int {
	c := new(big.Int).Div(field, big.NewInt(2))
	if c.Cmp(elem) < 0 {
		c.Sub(elem, field)
	} else {
		c.Set(elem)
	}
	return c
}

func circomLesserImpl(left *big.Int, right *big.Int, field *big.Int) bool {
	left = circomComparableElement(left, field)
	right = circomComparableElement(right, field)
	return left.Cmp(right) < 0
}

func CircomLesserEqHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if circomLesserImpl(inputs[0], inputs[1], field) || inputs[0].Cmp(inputs[1]) == 0 {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomLesserEq(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		b1 := builder.field.ToBigInt(n1)
		b2 := builder.field.ToBigInt(n2)
		if circomLesserImpl(b1, b2, builder.Field()) || b1.Cmp(b2) == 0 {
			return builder.eOne
		}
		return builder.eZero
	}
	s, _ := builder.NewHint(CircomLesserEqHint, 1, v1, v2)
	return s[0]
}

func CircomGreaterEqHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if circomLesserImpl(inputs[1], inputs[0], field) || inputs[0].Cmp(inputs[1]) == 0 {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomGreaterEq(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		b1 := builder.field.ToBigInt(n1)
		b2 := builder.field.ToBigInt(n2)
		if circomLesserImpl(b2, b1, builder.Field()) || b1.Cmp(b2) == 0 {
			return builder.eOne
		}
		return builder.eZero
	}
	s, _ := builder.NewHint(CircomGreaterEqHint, 1, v1, v2)
	return s[0]
}

func CircomLesserHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if circomLesserImpl(inputs[0], inputs[1], field) {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomLesser(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		b1 := builder.field.ToBigInt(n1)
		b2 := builder.field.ToBigInt(n2)
		if circomLesserImpl(b1, b2, builder.Field()) {
			return builder.eOne
		}
		return builder.eZero
	}
	s, _ := builder.NewHint(CircomLesserHint, 1, v1, v2)
	return s[0]
}

func CircomGreaterHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if circomLesserImpl(inputs[1], inputs[0], field) {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomGreater(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		b1 := builder.field.ToBigInt(n1)
		b2 := builder.field.ToBigInt(n2)
		if circomLesserImpl(b2, b1, builder.Field()) {
			return builder.eOne
		}
		return builder.eZero
	}
	s, _ := builder.NewHint(CircomGreaterHint, 1, v1, v2)
	return s[0]
}

func CircomEqHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if inputs[0].Cmp(inputs[1]) == 0 {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomEq(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		b1 := builder.field.ToBigInt(n1)
		b2 := builder.field.ToBigInt(n2)
		if b1.Cmp(b2) == 0 {
			return builder.eOne
		}
		return builder.eZero
	}
	s, _ := builder.NewHint(CircomEqHint, 1, v1, v2)
	return s[0]
}

func CircomNotEqHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if inputs[0].Cmp(inputs[1]) != 0 {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomNotEq(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		b1 := builder.field.ToBigInt(n1)
		b2 := builder.field.ToBigInt(n2)
		if b1.Cmp(b2) != 0 {
			return builder.eOne
		}
		return builder.eZero
	}
	s, _ := builder.NewHint(CircomNotEqHint, 1, v1, v2)
	return s[0]
}

func CircomBoolOrHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if inputs[0].Cmp(big.NewInt(0)) != 0 || inputs[1].Cmp(big.NewInt(0)) != 0 {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomBoolOr(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		if n1.IsZero() && n2.IsZero() {
			return builder.eZero
		}
		return builder.eOne
	}
	s, _ := builder.NewHint(CircomBoolOrHint, 1, v1, v2)
	return s[0]
}

func CircomBoolAndHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if inputs[0].Cmp(big.NewInt(0)) != 0 && inputs[1].Cmp(big.NewInt(0)) != 0 {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomBoolAnd(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		if n1.IsZero() || n2.IsZero() {
			return builder.eZero
		}
		return builder.eOne
	}
	s, _ := builder.NewHint(CircomBoolAndHint, 1, v1, v2)
	return s[0]
}

func CircomBitOrHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	outputs[0] = new(big.Int).Or(inputs[0], inputs[1])
	outputs[0].Mod(outputs[0], field)
	return nil
}

func (builder *builder) CircomBitOr(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		out := new(big.Int).Or(builder.field.ToBigInt(n1), builder.field.ToBigInt(n2))
		out.Mod(out, builder.Field())
		return expr.NewConstantExpression(builder.field.FromInterface(out))
	}
	s, _ := builder.NewHint(CircomBitOrHint, 1, v1, v2)
	return s[0]
}

func CircomBitAndHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	outputs[0] = new(big.Int).And(inputs[0], inputs[1])
	outputs[0].Mod(outputs[0], field)
	return nil
}

func (builder *builder) CircomBitAnd(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		out := new(big.Int).And(builder.field.ToBigInt(n1), builder.field.ToBigInt(n2))
		out.Mod(out, builder.Field())
		return expr.NewConstantExpression(builder.field.FromInterface(out))
	}
	s, _ := builder.NewHint(CircomBitAndHint, 1, v1, v2)
	return s[0]
}

func CircomBitXorHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	outputs[0] = new(big.Int).Xor(inputs[0], inputs[1])
	outputs[0].Mod(outputs[0], field)
	return nil
}

func (builder *builder) CircomBitXor(a frontend.Variable, b frontend.Variable) frontend.Variable {
	v1 := builder.toVariable(a)
	v2 := builder.toVariable(b)
	n1, v1Constant := builder.constantValue(v1)
	n2, v2Constant := builder.constantValue(v2)
	if v1Constant && v2Constant {
		out := new(big.Int).Xor(builder.field.ToBigInt(n1), builder.field.ToBigInt(n2))
		out.Mod(out, builder.Field())
		return expr.NewConstantExpression(builder.field.FromInterface(out))
	}
	s, _ := builder.NewHint(CircomBitXorHint, 1, v1, v2)
	return s[0]
}

func CircomBoolNotHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	if inputs[0].Cmp(big.NewInt(0)) == 0 {
		outputs[0] = big.NewInt(1)
	} else {
		outputs[0] = big.NewInt(0)
	}
	return nil
}

func (builder *builder) CircomBoolNot(a frontend.Variable) frontend.Variable {
	v := builder.toVariable(a)
	n, vConstant := builder.constantValue(v)
	if vConstant {
		if n.IsZero() {
			return builder.eOne
		}
		return builder.eZero
	}
	s, _ := builder.NewHint(CircomBoolNotHint, 1, v)
	return s[0]
}

func circomComplement256(elem *big.Int, field *big.Int) *big.Int {
	a := big.NewInt(0).Lsh(big.NewInt(1), 256)
	a.Sub(a, big.NewInt(1))
	a.Sub(a, elem)
	a.Mod(a, field)
	return a
}

func CircomComplementHint(field *big.Int, inputs []*big.Int, outputs []*big.Int) error {
	outputs[0] = circomComplement256(inputs[0], field)
	return nil
}

func (builder *builder) CircomComplement(a frontend.Variable) frontend.Variable {
	v := builder.toVariable(a)
	n, vConstant := builder.constantValue(v)
	if vConstant {
		out := circomComplement256(builder.field.ToBigInt(n), builder.Field())
		return expr.NewConstantExpression(builder.field.FromInterface(out))
	}
	s, _ := builder.NewHint(CircomComplementHint, 1, v)
	return s[0]
}
